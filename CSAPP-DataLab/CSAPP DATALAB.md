1、一个整数的补码的最小位数表示
思路关键：**最小位数问题转化成找最高位的1；负数的处理；二分法**

```
/* howManyBits - return the minimum number of bits required to represent x in two's complement

 *  Examples: howManyBits(12) = 5

 *            howManyBits(298) = 10

 *            howManyBits(-5) = 4

 *            howManyBits(0)  = 1

 *            howManyBits(-1) = 1

 *            howManyBits(0x80000000) = 32

 *  Legal ops: ! ~ & ^ | + << >>

 *  Max ops: 90

 *  Rating: 4

 */

int howManyBits(int x) {

  

  int b16,b8,b4,b2,b1,b0;

  int sign=x>>31;    //x的符号

  x = (sign&~x)|(~sign&x);/*如果x为正则不变，如果x为负则按位取反，因为要去掉符号位计算剩下需要几位，最后return值有+1，不影响

           例如1111 1111 1111 1111 1111 1111 1111 1101表示-3，其按位取反得0000 0000 0000 0000 0000 0000 0000 0010

           计算b16+b8+b4+b2+b1+b0=2，return 2+1=3，即-3最少需要3位比特位表示补码（相当101）*/

  

// 不断缩小范围

  b16 = !!(x>>16)<<4;//b16用于计数，检查最高十六位(32-16)是否有1，如果有，则!!(x>>16)=1, (1<<4)=0000...10000=2^4=16；如果没有，则为0

  x = x>>b16;//如果有（b16=16,至少需要16位），则将x右移16位；如果没有（b16=0）,x不变

  b8 = !!(x>>8)<<3;//如果上一步移动了，则检查最高8位(32-16-8)是否有1；如果上一步没移动，则检查最高24位(32-8)是否有1

           //如果有，b8=2^3=8；如果没有，则为0

  x = x>>b8;//如果有，x右移8位；如果没有，x不变

  b4 = !!(x>>4)<<2;

  x = x>>b4;

  b2 = !!(x>>2)<<1;

  x = x>>b2;

  b1 = !!(x>>1);

  x = x>>b1;

  b0 = x;

  return b16+b8+b4+b2+b1+b0+1;//+1表示加上符号位

}
```
2、浮点数的位数表示
**浮点数float:32位
double:64位
![[Pasted image 20240613173529.png]]
十进制的 E = exp - 127;
二进制的 M = 1.frac(二进制)
十进制的 V = ((-1)^s) * M * (2^E)
**